# State Management Schema

## Two-Layer Architecture

### Layer 1: Rich Action Records (`actions`)
Complete iteration records for debugging, analysis, and future compression.

### Layer 2: Compressed Context (`attempts`) 
Derived strings optimized for LLM prompting to prevent context overflow.

## Schema Definition

```python
"actions": [
    {
        # Iteration metadata
        "iteration": int,              # Iteration number (0-indexed)
        "timestamp": datetime,         # ISO format: "2024-01-15T10:30:00Z"
        "mode": "fast" | "deep",      # Reasoning mode for this iteration
        
        # Structured reasoning phases
        "thinking": str,               # Core reasoning output (all modes)
        "planning": str,               # Strategic planning (deep mode only)
        "reflection": str,             # Retrospective analysis (deep mode only)  
        "approach": str,               # Current persistent strategy
        
        # Tool execution results
        "tool_calls": [
            {
                "name": str,           # Tool name (e.g., "search", "read_file") 
                "args": dict,          # Tool arguments as provided
                "result": str,         # Tool result, truncated to ~1000 chars
                "outcome": enum,       # Enum: SUCCESS, FAILURE, ERROR, TIMEOUT
                
                # LLM compression fields (Phase 2 - empty strings in Phase 1)
                "insights": str,       # Key findings relevant to goal (1-2 sentences)
                "learning": str,       # Strategic learnings about approach effectiveness
                "relevance": str,      # How important to current goal: "high", "medium", "low"
            }
        ],
        
        # Iteration-level compression (Phase 2 - empty strings in Phase 1)
        "synthesis": str,              # How this iteration advances overall goal
        "progress": str,               # "advancing", "stuck", "regressing"
        "hypothesis": {                # Current belief being tested
            "belief": str,             # What agent thinks is true
            "test": str,               # How this iteration tests the belief
        },
    }
]

# Derived context for LLM prompting
"attempts": [                          # Generated by compress_actions()
    "searched 'python tutorial' → found 3 results, too general for debugging",
    "read logs/error.log → file empty, suggests logging not configured"
]
```

## Field Descriptions

### Core Metadata
- **iteration**: Sequential number starting from 0
- **timestamp**: ISO 8601 format for chronological ordering
- **mode**: Reasoning complexity level (`fast` for speed, `deep` for complex problems)

### Reasoning Fields
- **thinking**: Raw reasoning output from LLM (present in all modes)
- **planning**: Strategic planning phase (deep mode only, empty string in fast mode)
- **reflection**: Retrospective analysis of previous iterations (deep mode only)
- **approach**: Persistent strategy that spans multiple iterations (e.g., "debug API integration")

### Tool Execution
- **name**: Exact tool name as registered in tool registry (matches LLM tool call format)
- **args**: Complete argument dict passed to tool (matches LLM tool call format)
- **result**: Tool response truncated to prevent memory bloat
- **outcome**: Standardized execution result (SUCCESS, FAILURE, ERROR, TIMEOUT)
- **execution_time**: Basic performance monitoring for debugging

### Compression Fields (Phase 2)
- **insights**: LLM-extracted key findings relevant to current goal
- **learning**: Strategic insights about approach effectiveness
- **relevance**: Goal-relevance scoring for context filtering
- **synthesis**: Iteration-level summary of goal advancement
- **progress**: Trajectory assessment for stuck detection
- **hypothesis**: Structured belief tracking for hypothesis-driven reasoning

## Tool Outcome Enum

```python
class ToolOutcome(Enum):
    SUCCESS = "success"    # Tool executed successfully with expected output
    FAILURE = "failure"    # Tool executed but failed (e.g., file not found)
    ERROR = "error"        # Tool execution error (e.g., syntax error, crash)
    TIMEOUT = "timeout"    # Tool execution exceeded time limit
```

## Implementation Phases

**Phase 1**: Schema migration
- Replace `iterations` with `actions` structure
- Set compression fields to empty strings
- Implement basic `compress_actions()` using tool summaries

**Phase 2**: Intelligent compression
- Extend reasoning prompts to populate compression fields
- Implement relevance-based context filtering
- Use compressed fields in `attempts` generation

## Context Derivation

### Phase 1: Basic readable format
```python
def compress_actions(actions):
    return [f"{call['name']}({args_summary}) → {call['outcome']}" 
            for action in actions for call in action['tool_calls']]
```

### Phase 2: Use LLM-generated insights
```python
def compress_actions(actions, relevance_filter="medium"):
    compressed = []
    for action in actions:
        for call in action['tool_calls']:
            if call['relevance'] in ['high', 'medium']:  # Filter by relevance
                compressed.append(call['insights'] or fallback_format(call))
    return compressed
```

The `attempts` list is always derived from `actions` - never stored independently.